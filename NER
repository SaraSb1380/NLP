{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import nltk\n",
    "from nltk.tokenize import sent_tokenize, word_tokenize\n",
    "from collections import defaultdict\n",
    "from matplotlib import pyplot as plt\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "article='SCENE 1: [wind] [clop clop clop] KING ARTHUR: Whoa there!  [clop clop clop] SOLDIER #1: Halt!  Who goes there? ARTHUR: It is I, Arthur, son of Uther Pendragon, from the castle of Camelot. It is a nice castle. King of the Britons, defeator of the Saxons, sovereign of all England!SOLDIER #1: Pull the other one! ARTHUR: I am, ...  and this is my trusty servant Patsy.  We have ridden the length and breadth of the land in search of knights who will join me in my court at Camelot.  I must speak with your lord and master.SOLDIER #1: What?  Ridden on a horse? ARTHUR: Yes!'\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Tokenize the article into sentences: sentences\n",
    "sentences = sent_tokenize(article)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# Tokenize each sentence into words: token_sentences\n",
    "token_sentences = [word_tokenize(sent) for sent in sentences]\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "CC coordinating conjunction\n",
    "CD cardinal digit\n",
    "DT determiner\n",
    "EX existential there (like: “there is” … think of it like “there exists”)\n",
    "FW foreign word\n",
    "IN preposition/subordinating conjunction\n",
    "JJ adjective ‘big’\n",
    "JJR adjective, comparative ‘bigger’\n",
    "JJS adjective, superlative ‘biggest’\n",
    "LS list marker 1)\n",
    "MD modal could, will\n",
    "NN noun, singular ‘desk’\n",
    "NNS noun plural ‘desks’\n",
    "NNP proper noun, singular ‘Harrison’\n",
    "NNPS proper noun, plural ‘Americans’\n",
    "PDT predeterminer ‘all the kids’\n",
    "POS possessive ending parent’s\n",
    "PRP personal pronoun I, he, she\n",
    "PRP$ possessive pronoun my, his, hers\n",
    "RB adverb very, silently,\n",
    "RBR adverb, comparative better\n",
    "RBS adverb, superlative best\n",
    "RP particle give up\n",
    "TO, to go ‘to’ the store.\n",
    "UH interjection, errrrrrrrm\n",
    "VB verb, base form take\n",
    "VBD verb, past tense took\n",
    "VBG verb, gerund/present participle taking\n",
    "VBN verb, past participle taken\n",
    "VBP verb, sing. present, non-3d take\n",
    "VBZ verb, 3rd person sing. present takes\n",
    "WDT wh-determiner which\n",
    "WP wh-pronoun who, what\n",
    "WP$ possessive wh-pronoun whose\n",
    "WRB wh-abverb where, when\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[('SCENE', 'NN'), ('1', 'CD'), (':', ':'), ('[', 'NN'), ('wind', 'IN'), (']', 'JJ'), ('[', 'NNP'), ('clop', 'NN'), ('clop', 'NN'), ('clop', 'NN'), (']', 'NNP'), ('KING', 'NNP'), ('ARTHUR', 'NNP'), (':', ':'), ('Whoa', 'NNP'), ('there', 'EX'), ('!', '.')], [('[', 'NN'), ('clop', 'NN'), ('clop', 'NN'), ('clop', 'NN'), (']', 'NNP'), ('SOLDIER', 'NNP'), ('#', '#'), ('1', 'CD'), (':', ':'), ('Halt', 'NN'), ('!', '.')], [('Who', 'WP'), ('goes', 'VBZ'), ('there', 'RB'), ('?', '.')], [('ARTHUR', 'NN'), (':', ':'), ('It', 'PRP'), ('is', 'VBZ'), ('I', 'PRP'), (',', ','), ('Arthur', 'NNP'), (',', ','), ('son', 'NN'), ('of', 'IN'), ('Uther', 'NNP'), ('Pendragon', 'NNP'), (',', ','), ('from', 'IN'), ('the', 'DT'), ('castle', 'NN'), ('of', 'IN'), ('Camelot', 'NNP'), ('.', '.')], [('It', 'PRP'), ('is', 'VBZ'), ('a', 'DT'), ('nice', 'JJ'), ('castle', 'NN'), ('.', '.')], [('King', 'NNP'), ('of', 'IN'), ('the', 'DT'), ('Britons', 'NNP'), (',', ','), ('defeator', 'NN'), ('of', 'IN'), ('the', 'DT'), ('Saxons', 'NNP'), (',', ','), ('sovereign', 'NN'), ('of', 'IN'), ('all', 'DT'), ('England', 'NNP'), ('!', '.'), ('SOLDIER', 'NNP'), ('#', '#'), ('1', 'CD'), (':', ':'), ('Pull', 'VB'), ('the', 'DT'), ('other', 'JJ'), ('one', 'CD'), ('!', '.')], [('ARTHUR', 'NNP'), (':', ':'), ('I', 'PRP'), ('am', 'VBP'), (',', ','), ('...', ':'), ('and', 'CC'), ('this', 'DT'), ('is', 'VBZ'), ('my', 'PRP$'), ('trusty', 'JJ'), ('servant', 'JJ'), ('Patsy', 'NNP'), ('.', '.')], [('We', 'PRP'), ('have', 'VBP'), ('ridden', 'VBN'), ('the', 'DT'), ('length', 'NN'), ('and', 'CC'), ('breadth', 'NN'), ('of', 'IN'), ('the', 'DT'), ('land', 'NN'), ('in', 'IN'), ('search', 'NN'), ('of', 'IN'), ('knights', 'NNS'), ('who', 'WP'), ('will', 'MD'), ('join', 'VB'), ('me', 'PRP'), ('in', 'IN'), ('my', 'PRP$'), ('court', 'NN'), ('at', 'IN'), ('Camelot', 'NNP'), ('.', '.')], [('I', 'PRP'), ('must', 'MD'), ('speak', 'VB'), ('with', 'IN'), ('your', 'PRP$'), ('lord', 'NN'), ('and', 'CC'), ('master.SOLDIER', 'NN'), ('#', '#'), ('1', 'CD'), (':', ':'), ('What', 'WP'), ('?', '.')], [('Ridden', 'NNP'), ('on', 'IN'), ('a', 'DT'), ('horse', 'NN'), ('?', '.')], [('ARTHUR', 'NNP'), (':', ':'), ('Yes', 'UH'), ('!', '.')]]\n"
     ]
    }
   ],
   "source": [
    "# Tag each tokenized sentence into parts of speech: pos_sentences\n",
    "pos_sentences = [nltk.pos_tag(sent) for sent in token_sentences] \n",
    "print(pos_sentences)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# Create the named entity chunks: chunked_sentences,which segments and labels multi-token sequences\n",
    "chunked_sentences = nltk.ne_chunk_sents(pos_sentences,binary=True)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(NE SCENE/NN)\n",
      "(NE ARTHUR/NN)\n",
      "(NE Arthur/NNP)\n",
      "(NE Uther/NNP Pendragon/NNP)\n",
      "(NE Camelot/NNP)\n",
      "(NE Britons/NNP)\n",
      "(NE Saxons/NNP)\n",
      "(NE ARTHUR/NNP)\n",
      "(NE Camelot/NNP)\n",
      "(NE Ridden/NNP)\n",
      "(NE ARTHUR/NNP)\n"
     ]
    }
   ],
   "source": [
    "# Test for stems of the tree with 'NE' tags\n",
    "for sent in chunked_sentences:\n",
    "    for chunk in sent:\n",
    "        if hasattr(chunk, \"label\") and chunk.label() == \"NE\":\n",
    "            print(chunk)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "#  chart the diversity of named entity types in the articles"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Comparing spacy with NLTK"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CARDINAL 1\n",
      "PERSON KING ARTHUR\n",
      "CARDINAL #1\n",
      "PERSON Arthur\n",
      "WORK_OF_ART Uther Pendragon\n",
      "LOC Camelot\n",
      "GPE Britons\n",
      "LAW Saxons\n",
      "MONEY 1\n",
      "PERSON Patsy\n",
      "LOC Camelot\n",
      "CARDINAL #1\n",
      "PERSON Ridden\n",
      "PERSON ARTHUR\n"
     ]
    }
   ],
   "source": [
    "# Import spacy\n",
    "import spacy\n",
    "\n",
    "# Instantiate the English model: nlp\n",
    "nlp = spacy.load('en',tagger=False, parser=False, matcher=False)\n",
    "\n",
    "# Create a new document: doc\n",
    "doc = nlp(article)\n",
    "\n",
    "# Print all of the found entities and their labels\n",
    "for ent in doc.ents:\n",
    "    print((ent.label_), (ent.text))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "PERSON KING ARTHUR\n",
      "PERSON Arthur\n",
      "PERSON Patsy\n",
      "PERSON Ridden\n",
      "PERSON ARTHUR\n"
     ]
    }
   ],
   "source": [
    "for ent in doc.ents:\n",
    "    \n",
    "    if (ent.label_==\"PERSON\"):\n",
    "        print(ent.label_, ent.text)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#  create an NP-chunker, we will first define a chunk grammar, chunk grammar use tag patterns to describe sequences of tagged word"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[Tree('S', [Tree('NP', [('SCENE', 'NN')]), ('1', 'CD'), (':', ':'), Tree('NP', [('[', 'NN')]), ('wind', 'IN'), (']', 'JJ'), ('[', 'NNP'), Tree('NP', [('clop', 'NN')]), Tree('NP', [('clop', 'NN')]), Tree('NP', [('clop', 'NN')]), (']', 'NNP'), ('KING', 'NNP'), ('ARTHUR', 'NNP'), (':', ':'), ('Whoa', 'NNP'), ('there', 'EX'), ('!', '.')]), Tree('S', [Tree('NP', [('[', 'NN')]), Tree('NP', [('clop', 'NN')]), Tree('NP', [('clop', 'NN')]), Tree('NP', [('clop', 'NN')]), (']', 'NNP'), ('SOLDIER', 'NNP'), ('#', '#'), ('1', 'CD'), (':', ':'), Tree('NP', [('Halt', 'NN')]), ('!', '.')]), Tree('S', [('Who', 'WP'), ('goes', 'VBZ'), ('there', 'RB'), ('?', '.')]), Tree('S', [Tree('NP', [('ARTHUR', 'NN')]), (':', ':'), ('It', 'PRP'), ('is', 'VBZ'), ('I', 'PRP'), (',', ','), ('Arthur', 'NNP'), (',', ','), Tree('NP', [('son', 'NN')]), ('of', 'IN'), ('Uther', 'NNP'), ('Pendragon', 'NNP'), (',', ','), ('from', 'IN'), Tree('NP', [('the', 'DT'), ('castle', 'NN')]), ('of', 'IN'), ('Camelot', 'NNP'), ('.', '.')]), Tree('S', [('It', 'PRP'), ('is', 'VBZ'), Tree('NP', [('a', 'DT'), ('nice', 'JJ'), ('castle', 'NN')]), ('.', '.')]), Tree('S', [('King', 'NNP'), ('of', 'IN'), ('the', 'DT'), ('Britons', 'NNP'), (',', ','), Tree('NP', [('defeator', 'NN')]), ('of', 'IN'), ('the', 'DT'), ('Saxons', 'NNP'), (',', ','), Tree('NP', [('sovereign', 'NN')]), ('of', 'IN'), ('all', 'DT'), ('England', 'NNP'), ('!', '.'), ('SOLDIER', 'NNP'), ('#', '#'), ('1', 'CD'), (':', ':'), ('Pull', 'VB'), ('the', 'DT'), ('other', 'JJ'), ('one', 'CD'), ('!', '.')]), Tree('S', [('ARTHUR', 'NNP'), (':', ':'), ('I', 'PRP'), ('am', 'VBP'), (',', ','), ('...', ':'), ('and', 'CC'), ('this', 'DT'), ('is', 'VBZ'), ('my', 'PRP$'), ('trusty', 'JJ'), ('servant', 'JJ'), ('Patsy', 'NNP'), ('.', '.')]), Tree('S', [('We', 'PRP'), ('have', 'VBP'), ('ridden', 'VBN'), Tree('NP', [('the', 'DT'), ('length', 'NN')]), ('and', 'CC'), Tree('NP', [('breadth', 'NN')]), ('of', 'IN'), Tree('NP', [('the', 'DT'), ('land', 'NN')]), ('in', 'IN'), Tree('NP', [('search', 'NN')]), ('of', 'IN'), ('knights', 'NNS'), ('who', 'WP'), ('will', 'MD'), ('join', 'VB'), ('me', 'PRP'), ('in', 'IN'), ('my', 'PRP$'), Tree('NP', [('court', 'NN')]), ('at', 'IN'), ('Camelot', 'NNP'), ('.', '.')]), Tree('S', [('I', 'PRP'), ('must', 'MD'), ('speak', 'VB'), ('with', 'IN'), ('your', 'PRP$'), Tree('NP', [('lord', 'NN')]), ('and', 'CC'), Tree('NP', [('master.SOLDIER', 'NN')]), ('#', '#'), ('1', 'CD'), (':', ':'), ('What', 'WP'), ('?', '.')]), Tree('S', [('Ridden', 'NNP'), ('on', 'IN'), Tree('NP', [('a', 'DT'), ('horse', 'NN')]), ('?', '.')]), Tree('S', [('ARTHUR', 'NNP'), (':', ':'), ('Yes', 'UH'), ('!', '.')])]\n"
     ]
    }
   ],
   "source": [
    "grammar = \"NP: {<DT>?<JJ>*<NN>}\" \n",
    "# grammar=\"NP: {<DT>?<JJ.*>*<NN.*>+}\"\n",
    "cp = nltk.RegexpParser(grammar) \n",
    "result = [cp.parse(pos) for pos in pos_sentences]\n",
    "print(result) \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {},
   "outputs": [],
   "source": [
    "tree1 = nltk.Tree('NNP', ['ARTHUR'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [],
   "source": [
    "tree1.draw()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
